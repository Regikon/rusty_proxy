# Rusty Proxy

Небольшое приложение-прокси, написанное (с болью) на Rust.

## Как запустить?

Для запуска в настоящий момент обязательно нужно иметь
SSL сертификаты (нет возможности выбрать тип проксирования).

Для домена mail.ru уже сгенерирован сертификат и он располагается
в директории ./certs. Там же находится скрипт для генерации
сертификата, подписанного корневым сертификатом.

Для указания другого домена нужно отредактировать файл ca.ext и
перечислить сам домен и его синонимы в строке subjectAltName.

Приложение состоит из трех компонентов:
* mitm - реализация прокси
* api - апи для доступа к сканнеру
* mongodb - база даннных для сущностей

Для запуска в докере необходимо вызвать команду

```bash

docker-compose -f ./docker-compose.yaml up

```

По умолчанию прокси поднимается на адресе http://0.0.0.0:8080, а
API - на http://0.0.0.0:8000.

## Описание API

- GET /requests - выводит все пары запрос-ответ, что есть в БД. Может вернуть большую бомбу, если запросов уже было много
- GET /requests/{id} - выводит пару запрос-ответ по заданному id. Id является hex-строкой
- GET /repeat/{id} - повторно отправляет запрос из пары с заданным id. Возвращает результат запроса
- GET /scan/{id} - сканирует запрос на XSS уязвимости. Выводит массив названий параметров, которые уязвимы

## Для проверки прокси

### curl

Для проверки через curl можно воспользоваться командами

```bash

curl --insecure -x http://127.0.0.1:8080 https://mail.ru/
curl -x http://127.0.0.1:8080 http://mail.ru

```

Важно. Не нужно подключаться к прокси как к https серверу,
вам не ответят.

### Браузер

Для проверки браузером нужно добавить в его настройки прокси
IP прокси и добавить корневой сертификат rootCA.crt в доверенные.

Если всё ок, то будет загружена страница https://mail.ru
(или другая, подписанная сертификатом). Возможно сгенерированный
сертификат не охватывает все домены mail.ru, но с почтой результат
удовлетворительный.

## Особенности реализации

Тело запросов и ответов в базе данных может храниться в виде:
* Пар ключ-значение, если MIME-тип тела x-www-form-urlencoded
* Как чистые байты в противном случае

Тело запроса не переводится в строку, так как вообще говоря оно
может быть представлено в виде бинарных данных, которые не являются
валидным ascii или utf-8. Поэтому сканер запросов работает не со строками,
а с байтовыми последовательностями.

Можно было продолжить парсить MIME для тела, чтобы расшифровывать все текстовые
типы, но это фича, закладываемая на будущее, и не реализуемая быстро.

## О зависимостях

Здесь перечислены зависимости кода и объяснения, что они такое

* hyper - низкоуровневая реализация http протокола
* tokio - асинхронный runtime для rust
* hyper-util - небольшие хелперы для hyper
* http-body-util - хелпер-структуры для тел http сообщений
* http - структуры представляющие сущности http
* log - пакет макросов для логирования
* simplelog - реализация логирования
* bytes - пакет для некопирующей работы с байтами
* thiserror - пакет макросов для типов-ошибок
* rustls - реализация TLS для rust
* tokio-rustls - обертка rustls для асинхронной работы
* webpki-roots - корневые сертификаты mozilla (для работы клиентской стороны прокси)
* dotenv - реализация парсинга из .env файла для rust
* multimap - структура данных для хранения множества значений с одним ключом
* url_encoded_data - пакет для запаковки и распаковки application/x-www-form-urlencoded
* serde - фреймворк для сериализации и десериализации данных
* futures - библиотека для работы с async/await
* axum - REST API фреймворк
* bson - работа с bson (и плагины для serde)
* mongodb - драйвер БД
